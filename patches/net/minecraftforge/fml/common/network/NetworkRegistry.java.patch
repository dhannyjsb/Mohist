--- ../src-base/minecraft/net/minecraftforge/fml/common/network/NetworkRegistry.java
+++ ../src-work/minecraft/net/minecraftforge/fml/common/network/NetworkRegistry.java
@@ -19,17 +19,12 @@
 
 package net.minecraftforge.fml.common.network;
 
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.handler.codec.MessageToMessageCodec;
 import io.netty.util.AttributeKey;
-
-import java.util.Collection;
-import java.util.EnumMap;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Collectors;
-
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.inventory.Container;
@@ -46,23 +41,19 @@
 import net.minecraftforge.fml.common.network.simpleimpl.SimpleNetworkWrapper;
 import net.minecraftforge.fml.relauncher.Side;
 
-import com.google.common.collect.ImmutableMap;
-import com.google.common.collect.Maps;
-
 import javax.annotation.Nullable;
+import java.util.Collection;
+import java.util.EnumMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
 
 /**
  * @author cpw
  *
  */
-public enum NetworkRegistry
-{
+public enum NetworkRegistry {
     INSTANCE;
-    private EnumMap<Side,Map<String,FMLEmbeddedChannel>> channels = Maps.newEnumMap(Side.class);
-    private Map<ModContainer, NetworkModHolder> registry = Maps.newHashMap();
-    private Map<ModContainer, IGuiHandler> serverGuiHandlers = Maps.newHashMap();
-    private Map<ModContainer, IGuiHandler> clientGuiHandlers = Maps.newHashMap();
-
     /**
      * Set in the {@link ChannelHandlerContext}
      */
@@ -71,47 +62,20 @@
     public static final AttributeKey<ModContainer> MOD_CONTAINER = AttributeKey.valueOf("fml:modContainer");
     public static final AttributeKey<INetHandler> NET_HANDLER = AttributeKey.valueOf("fml:netHandler");
     public static final AttributeKey<Boolean> FML_MARKER = AttributeKey.valueOf("fml:hasMarker");
-
     // Version 1: ServerHello only contains this value as a byte
     // Version 2: ServerHello additionally contains a 4 byte (int) dimension for the logging in client
     public static final byte FML_PROTOCOL = 2;
+    private EnumMap<Side, Map<String, FMLEmbeddedChannel>> channels = Maps.newEnumMap(Side.class);
+    private Map<ModContainer, NetworkModHolder> registry = Maps.newHashMap();
+    private Map<ModContainer, IGuiHandler> serverGuiHandlers = Maps.newHashMap();
+    private Map<ModContainer, IGuiHandler> clientGuiHandlers = Maps.newHashMap();
 
-    private NetworkRegistry()
-    {
-        channels.put(Side.CLIENT, Maps.<String,FMLEmbeddedChannel>newConcurrentMap());
-        channels.put(Side.SERVER, Maps.<String,FMLEmbeddedChannel>newConcurrentMap());
+    private NetworkRegistry() {
+        channels.put(Side.CLIENT, Maps.<String, FMLEmbeddedChannel>newConcurrentMap());
+        channels.put(Side.SERVER, Maps.<String, FMLEmbeddedChannel>newConcurrentMap());
     }
 
     /**
-     * Represents a target point for the ALLROUNDPOINT target.
-     *
-     * @author cpw
-     *
-     */
-    public static class TargetPoint {
-        /**
-         * A target point
-         * @param dimension The dimension to target
-         * @param x The X coordinate
-         * @param y The Y coordinate
-         * @param z The Z coordinate
-         * @param range The range
-         */
-        public TargetPoint(int dimension, double x, double y, double z, double range)
-        {
-            this.x = x;
-            this.y = y;
-            this.z = z;
-            this.range = range;
-            this.dimension = dimension;
-        }
-        public final double x;
-        public final double y;
-        public final double z;
-        public final double range;
-        public final int dimension;
-    }
-    /**
      * Create a new synchronous message channel pair based on netty.
      *
      * There are two preconstructed models available:
@@ -147,18 +111,15 @@
      * @param handlers
      * @return
      */
-    public EnumMap<Side,FMLEmbeddedChannel> newChannel(String name, ChannelHandler... handlers)
-    {
-        if (channels.get(Side.CLIENT).containsKey(name) || channels.get(Side.SERVER).containsKey(name) || name.startsWith("MC|") || name.startsWith("\u0001") || name.startsWith("FML"))
-        {
+    public EnumMap<Side, FMLEmbeddedChannel> newChannel(String name, ChannelHandler... handlers) {
+        if (channels.get(Side.CLIENT).containsKey(name) || channels.get(Side.SERVER).containsKey(name) || name.startsWith("MC|") || name.startsWith("\u0001") || name.startsWith("FML")) {
             throw new RuntimeException("That channel is already registered");
         }
-        EnumMap<Side,FMLEmbeddedChannel> result = Maps.newEnumMap(Side.class);
+        EnumMap<Side, FMLEmbeddedChannel> result = Maps.newEnumMap(Side.class);
 
-        for (Side side : Side.values())
-        {
+        for (Side side : Side.values()) {
             FMLEmbeddedChannel channel = new FMLEmbeddedChannel(name, side, handlers);
-            channels.get(side).put(name,channel);
+            channels.get(side).put(name, channel);
             result.put(side, channel);
         }
         return result;
@@ -170,20 +131,20 @@
      * @param name The name of the channel
      * @return A {@link SimpleNetworkWrapper} for handling this channel
      */
-    public SimpleNetworkWrapper newSimpleChannel(String name)
-    {
+    public SimpleNetworkWrapper newSimpleChannel(String name) {
         return new SimpleNetworkWrapper(name);
     }
+
     /**
      * Construct a new {@link FMLEventChannel} for the channel.
      *
      * @param name The name of the channel
      * @return An {@link FMLEventChannel} for handling this channel
      */
-    public FMLEventChannel newEventDrivenChannel(String name)
-    {
+    public FMLEventChannel newEventDrivenChannel(String name) {
         return new FMLEventChannel(name);
     }
+
     /**
      * INTERNAL Create a new channel pair with the specified name and channel handlers.
      * This is used internally in forge and FML
@@ -193,38 +154,33 @@
      * @param handlers Some {@link ChannelHandler} for the channel
      * @return an {@link EnumMap} of the pair of channels. keys are {@link Side}. There will always be two entries.
      */
-    public EnumMap<Side,FMLEmbeddedChannel> newChannel(ModContainer container, String name, ChannelHandler... handlers)
-    {
-        if (channels.get(Side.CLIENT).containsKey(name) || channels.get(Side.SERVER).containsKey(name) || name.startsWith("MC|") || name.startsWith("\u0001") || (name.startsWith("FML") && !("FML".equals(container.getModId()))))
-        {
+    public EnumMap<Side, FMLEmbeddedChannel> newChannel(ModContainer container, String name, ChannelHandler... handlers) {
+        if (channels.get(Side.CLIENT).containsKey(name) || channels.get(Side.SERVER).containsKey(name) || name.startsWith("MC|") || name.startsWith("\u0001") || (name.startsWith("FML") && !("FML".equals(container.getModId())))) {
             throw new RuntimeException("That channel is already registered");
         }
-        EnumMap<Side,FMLEmbeddedChannel> result = Maps.newEnumMap(Side.class);
+        EnumMap<Side, FMLEmbeddedChannel> result = Maps.newEnumMap(Side.class);
 
-        for (Side side : Side.values())
-        {
+        for (Side side : Side.values()) {
             FMLEmbeddedChannel channel = new FMLEmbeddedChannel(container, name, side, handlers);
-            channels.get(side).put(name,channel);
+            channels.get(side).put(name, channel);
             result.put(side, channel);
         }
         return result;
     }
 
-    public FMLEmbeddedChannel getChannel(String name, Side source)
-    {
+    public FMLEmbeddedChannel getChannel(String name, Side source) {
         return channels.get(source).get(name);
     }
+
     /**
      * Register an {@link IGuiHandler} for the supplied mod object.
      *
      * @param mod The mod to handle GUIs for
      * @param handler A handler for creating GUI related objects
      */
-    public void registerGuiHandler(Object mod, IGuiHandler handler)
-    {
+    public void registerGuiHandler(Object mod, IGuiHandler handler) {
         ModContainer mc = FMLCommonHandler.instance().findContainerFor(mod);
-        if (mc == null)
-        {
+        if (mc == null) {
             FMLLog.log.error("Mod of type {} attempted to register a gui network handler during a construction phase", mod.getClass().getName());
             throw new RuntimeException("Invalid attempt to create a GUI during mod construction. Use an EventHandler instead");
         }
@@ -244,16 +200,12 @@
      * @return The server side GUI object (An instance of {@link Container})
      */
     @Nullable
-    public Container getRemoteGuiContainer(ModContainer mc, EntityPlayerMP player, int modGuiId, World world, int x, int y, int z)
-    {
+    public Container getRemoteGuiContainer(ModContainer mc, EntityPlayerMP player, int modGuiId, World world, int x, int y, int z) {
         IGuiHandler handler = serverGuiHandlers.get(mc);
 
-        if (handler != null)
-        {
-            return (Container)handler.getServerGuiElement(modGuiId, player, world, x, y, z);
-        }
-        else
-        {
+        if (handler != null) {
+            return (Container) handler.getServerGuiElement(modGuiId, player, world, x, y, z);
+        } else {
             return null;
         }
     }
@@ -270,8 +222,7 @@
      * @return The client side GUI object (An instance of {@link net.minecraft.client.gui.Gui})
      */
     @Nullable
-    public Object getLocalGuiContainer(ModContainer mc, EntityPlayer player, int modGuiId, World world, int x, int y, int z)
-    {
+    public Object getLocalGuiContainer(ModContainer mc, EntityPlayer player, int modGuiId, World world, int x, int y, int z) {
         IGuiHandler handler = clientGuiHandlers.get(mc);
         return handler.getClientGuiElement(modGuiId, player, world, x, y, z);
     }
@@ -282,8 +233,7 @@
      * @param source the side
      * @return if there's a channel
      */
-    public boolean hasChannel(String channelName, Side source)
-    {
+    public boolean hasChannel(String channelName, Side source) {
         return channels.get(source).containsKey(channelName);
     }
 
@@ -294,21 +244,18 @@
      * @param remoteVersionRange the acceptable remote range
      * @param asmHarvestedData internal data
      */
-    public void register(ModContainer fmlModContainer, Class<?> clazz, @Nullable String remoteVersionRange, ASMDataTable asmHarvestedData)
-    {
+    public void register(ModContainer fmlModContainer, Class<?> clazz, @Nullable String remoteVersionRange, ASMDataTable asmHarvestedData) {
         NetworkModHolder networkModHolder = new NetworkModHolder(fmlModContainer, clazz, remoteVersionRange, asmHarvestedData);
         registry.put(fmlModContainer, networkModHolder);
         networkModHolder.testVanillaAcceptance();
     }
 
-    public boolean isVanillaAccepted(Side from)
-    {
+    public boolean isVanillaAccepted(Side from) {
         return registry.values().stream()
                 .allMatch(mod -> mod.acceptsVanilla(from));
     }
 
-    public Collection<String> getRequiredMods(Side from)
-    {
+    public Collection<String> getRequiredMods(Side from) {
         return registry.values().stream()
                 .filter(mod -> !mod.acceptsVanilla(from))
                 .map(mod -> mod.getContainer().getName())
@@ -316,8 +263,7 @@
                 .collect(Collectors.toList());
     }
 
-    public Map<ModContainer,NetworkModHolder> registry()
-    {
+    public Map<ModContainer, NetworkModHolder> registry() {
         return ImmutableMap.copyOf(registry);
     }
 
@@ -326,8 +272,7 @@
      * @param side the side
      * @return the set of channel names
      */
-    public Set<String> channelNamesFor(Side side)
-    {
+    public Set<String> channelNamesFor(Side side) {
         return channels.get(side).keySet();
     }
 
@@ -336,19 +281,45 @@
      * @param networkDispatcher The dispatcher firing
      * @param origin which side the dispatcher is on
      */
-    public void fireNetworkHandshake(NetworkDispatcher networkDispatcher, Side origin)
-    {
+    public void fireNetworkHandshake(NetworkDispatcher networkDispatcher, Side origin) {
         NetworkHandshakeEstablished handshake = new NetworkHandshakeEstablished(networkDispatcher, networkDispatcher.getNetHandler(), origin);
-        for (FMLEmbeddedChannel channel : channels.get(origin).values())
-        {
+        for (FMLEmbeddedChannel channel : channels.get(origin).values()) {
             channel.attr(FMLOutboundHandler.FML_MESSAGETARGET).set(OutboundTarget.DISPATCHER);
             channel.attr(FMLOutboundHandler.FML_MESSAGETARGETARGS).set(networkDispatcher);
             channel.pipeline().fireUserEventTriggered(handshake);
         }
     }
 
-    public void cleanAttributes()
-    {
+    public void cleanAttributes() {
         channels.values().forEach(map -> map.values().forEach(FMLEmbeddedChannel::cleanAttributes));
     }
+
+    /**
+     * Represents a target point for the ALLROUNDPOINT target.
+     *
+     * @author cpw
+     *
+     */
+    public static class TargetPoint {
+        public final double x;
+        public final double y;
+        public final double z;
+        public final double range;
+        public final int dimension;
+        /**
+         * A target point
+         * @param dimension The dimension to target
+         * @param x The X coordinate
+         * @param y The Y coordinate
+         * @param z The Z coordinate
+         * @param range The range
+         */
+        public TargetPoint(int dimension, double x, double y, double z, double range) {
+            this.x = x;
+            this.y = y;
+            this.z = z;
+            this.range = range;
+            this.dimension = dimension;
+        }
+    }
 }
